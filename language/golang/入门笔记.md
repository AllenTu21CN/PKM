# GoLang入门学习随手笔记

* 参考资料
    * [Go 指南(中文)](https://tour.go-zh.org/list)
    * https://go.dev/

* Hello World

    ```Go
    package main

    import "fmt"
    // 分组形式导入
    import (
        "fmt"
        "math"
    )

    func main() {
        fmt.Println("Hello World")
    }
    ```

* 按照**约定**，包名与导入路径的最后一个元素一致。例如，"math/rand" 包中的源码均以 package rand 语句开始。

* 包里只有大写开头的变量、方法才会被导出，即只能访问包里大写开头的方法、对象

* 多值返回和接受、返回值命名

    ```Go
    package main

    import "fmt"

    func split(sum int) (x, y int) {
        x = sum * 4 / 9
        y = sum - x
        return // 这种直接返回的形式在长函数中不推荐
    }

    func swap(x, y string) (string, string) {
        return y, x
    }

    func main() {
        fmt.Println(split(17))
    }
    ```

* 变量和常量
    * 除了函数形参，声明一个变量需要加`var`关键词，常量用`const`关键词；
    * 如果申明时初始化，可以省略变量类型；或者使用`:=`省略类型和`var`
    * 变量声明也可以使用分组语法块
    * 必须显示类型转换
    * 数值`常量`是一个很高精度的类型，能存储比int64还要大很多的值
    ```Go
	var i, j int = 1, 2
	k := 3
    c, python, java := true, false, "no!"
    
    var (
        ToBe   bool       = false
        MaxInt uint64     = 1<<64 - 1
    )

    // 类型转换
    var x, y int = 3, 4
	var f float64 = math.Sqrt(float64(x*x + y*y))
	var z uint = uint(f)
	var w float64 = float64(x)
    ```

* 基本类型
    ```Go
    bool

    string

    int  int8  int16  int32  int64
    uint uint8 uint16 uint32 uint64 uintptr

    byte // uint8 的别名

    rune // int32 的别名, 表示一个 Unicode 码点

    float32 float64

    complex64 complex128
    ```

* `fmt.Printf`

    ```Go
    // 打印变量值，自动空格分割
    fmt.Println(a, b)

    // 格式化输出 变量类型:%T 变量值:%v
    fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
    ```

* 循环

    ```Go
    sum := 0
	for i := 0; i < 10; i++ {
		sum += i
    }
    
    for sum < 1000 {
		sum += sum
    }
    
    for {
        sum += sum
	}
    ```

* 判断

    ```Go
	if x < 0 {
        return
    }
    
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
    // 这里开始就不能使用 v 了
    
    // case可以不是常量、整数，甚至可以是表达式
	switch os := runtime.GOOS; os {
	case "darwin":
        fmt.Println("OS X.")
        // 默认包含break 
	case "linux":
        fmt.Println("Linux.")
        fallthrough // 显式指定不break
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
    }
    
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
    ```

* defer 推迟调用的函数其参数会立即求值，但直到外层函数返回后该函数才被调用
    * 推迟的原理是将函数压栈，所以多个defer的函数会后进先出的被执行

    ```Go
    func main() {
        i := 1
        defer fmt.Println("defer:", i)  // 后执行，输出1
        i++
        fmt.Println("", i)  // 先执行，输出2
    }
    ```

* Go的指针大部分与C一样，但是没有指针运算
    ```Go
    type Vertex struct {
        X int
        Y int
    }

    func main() {
        v := Vertex{1, 2}
        p := &v
        p.X = 1e9   // 等同于(*p).X = 1e9，没有->运算符
        fmt.Println(v)
    }

    p := &Vertex{2, 3} // 创建一个 *Vertex 类型的结构体（指针），无须像C/C++一样new
    ```

* 结构体

    ```Go
    type Vertex struct {
        X, Y int
    }

    var (
        v1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体
        v2 = Vertex{X: 1}  // Y:0 被隐式地赋予
        v3 = Vertex{}      // X:0 Y:0
        p  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）
    )
    ```

* 数组和切片

    ```Go
    var a [10]int

    primes := [6]int{2, 3, 5, 7, 11, 13}

    var s []int = primes[1:4] // 切片，值为[3, 5, 7]，左开右闭

    primes := []int{2, 3, 5, 7, 11, 13} // 这是切片
    ```

* XXXX

    ```Go
    ```
* XXXX

    ```Go
    ```
* XXXX

    ```Go
    ```
* XXXX

    ```Go
    ```
* XXXX

    ```Go
    ```
* XXXX

    ```Go
    ```
* XXXX

    ```Go
    ```
* XXXX

    ```Go
    ```
* XXXX

    ```Go
    ```
